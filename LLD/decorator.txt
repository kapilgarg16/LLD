// Pizza.java
public interface Pizza {
    String getDescription();
    double cost();
}

// PlainPizza.java
public class PlainPizza implements Pizza {
    @Override
    public String getDescription() {
        return "Plain pizza";
    }

    @Override
    public double cost() {
        return 8.0; // Base price of the pizza
    }
}

// PizzaDecorator.java
public abstract class PizzaDecorator implements Pizza {
    protected Pizza decoratedPizza;

    public PizzaDecorator(Pizza decoratedPizza) {
        this.decoratedPizza = decoratedPizza;
    }

    @Override
    public String getDescription() {
        return decoratedPizza.getDescription();
    }

    @Override
    public double cost() {
        return decoratedPizza.cost();
    }
}

// CheeseDecorator.java
public class CheeseDecorator extends PizzaDecorator {
    public CheeseDecorator(Pizza decoratedPizza) {
        super(decoratedPizza);
    }

    @Override
    public String getDescription() {
        return decoratedPizza.getDescription() + ", cheese";
    }

    @Override
    public double cost() {
        return decoratedPizza.cost() + 1.5; // Cost of cheese topping
    }
}

// PepperoniDecorator.java
public class PepperoniDecorator extends PizzaDecorator {
    public PepperoniDecorator(Pizza decoratedPizza) {
        super(decoratedPizza);
    }

    @Override
    public String getDescription() {
        return decoratedPizza.getDescription() + ", pepperoni";
    }

    @Override
    public double cost() {
        return decoratedPizza.cost() + 2.0; // Cost of pepperoni topping
    }
}

// MushroomDecorator.java
public class MushroomDecorator extends PizzaDecorator {
    public MushroomDecorator(Pizza decoratedPizza) {
        super(decoratedPizza);
    }

    @Override
    public String getDescription() {
        return decoratedPizza.getDescription() + ", mushrooms";
    }

    @Override
    public double cost() {
        return decoratedPizza.cost() + 1.0; // Cost of mushroom topping
    }
}

// OliveDecorator.java
public class OliveDecorator extends PizzaDecorator {
    public OliveDecorator(Pizza decoratedPizza) {
        super(decoratedPizza);
    }

    @Override
    public String getDescription() {
        return decoratedPizza.getDescription() + ", olives";
    }

    @Override
    public double cost() {
        return decoratedPizza.cost() + 0.75; // Cost of olive topping
    }
}

\\\\\\\\\\\\\\\\\\\\\\\\// PizzaShop.java
public class PizzaShop {
    public static void main(String[] args) {
        Pizza pizza = new PlainPizza();
        System.out.println(pizza.getDescription() + " $" + pizza.cost());

        pizza = new CheeseDecorator(pizza);
        System.out.println(pizza.getDescription() + " $" + pizza.cost());

        pizza = new PepperoniDecorator(pizza);
        System.out.println(pizza.getDescription() + " $" + pizza.cost());

        pizza = new MushroomDecorator(pizza);
        System.out.println(pizza.getDescription() + " $" + pizza.cost());

        pizza = new OliveDecorator(pizza);
        System.out.println(pizza.getDescription() + " $" + pizza.cost());
    }
}

https://www.geeksforgeeks.org/decorator-design-pattern-in-java-with-example/
Absolutely, Kapil ‚Äî let‚Äôs dive into this properly and deeply üëá

--------------------------------------------------------------------------------------------

## üß© **Decorator Pattern (Structural Design Pattern)**

### **1Ô∏è‚É£ What It Is**

The **Decorator Pattern** allows you to **add new behaviors or responsibilities** to objects **dynamically**, without modifying their original class or creating a ton of subclasses.

In simple terms:

> It‚Äôs a way to **wrap** an object with another object that **adds extra features**.

---

### **2Ô∏è‚É£ The Real-World Analogy**

Imagine you‚Äôre ordering a coffee ‚òï.

* Base coffee: ‚Çπ100
* Add milk ‚Üí +‚Çπ20
* Add whipped cream ‚Üí +‚Çπ30
* Add chocolate ‚Üí +‚Çπ25

Instead of creating a separate class for each combination (like `CoffeeWithMilkAndCream`, `CoffeeWithChocolateAndMilk`, etc.),
you **wrap** your `BaseCoffee` with decorators:

* `new MilkDecorator(new CreamDecorator(new Coffee()))`

Each decorator adds its own behavior (extra cost, description, etc.), **without modifying** the base `Coffee` class.

---

### **3Ô∏è‚É£ Structure Diagram**

```
Component (interface)
   ‚Üë
ConcreteComponent (base object)
   ‚Üë
Decorator (abstract wrapper)
   ‚Üë
ConcreteDecorators (add behavior)
```

---

### **4Ô∏è‚É£ Java Example**

```java
// Step 1: Component interface
interface Coffee {
    String getDescription();
    double getCost();
}

// Step 2: Concrete component
class SimpleCoffee implements Coffee {
    public String getDescription() {
        return "Simple Coffee";
    }
    public double getCost() {
        return 50;
    }
}

// Step 3: Abstract decorator
abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;
    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
    public String getDescription() {
        return coffee.getDescription();
    }
    public double getCost() {
        return coffee.getCost();
    }
}

// Step 4: Concrete decorators
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    public String getDescription() {
        return super.getDescription() + ", Milk";
    }
    public double getCost() {
        return super.getCost() + 20;
    }
}

class WhipDecorator extends CoffeeDecorator {
    public WhipDecorator(Coffee coffee) {
        super(coffee);
    }
    public String getDescription() {
        return super.getDescription() + ", Whipped Cream";
    }
    public double getCost() {
        return super.getCost() + 30;
    }
}

// Step 5: Client code
public class DecoratorDemo {
    public static void main(String[] args) {
        Coffee coffee = new SimpleCoffee();
        System.out.println(coffee.getDescription() + " ‚Çπ" + coffee.getCost());

        coffee = new MilkDecorator(coffee);
        coffee = new WhipDecorator(coffee);
        System.out.println(coffee.getDescription() + " ‚Çπ" + coffee.getCost());
    }
}
```

**Output:**

```
Simple Coffee ‚Çπ50.0
Simple Coffee, Milk, Whipped Cream ‚Çπ100.0
```

---

### **5Ô∏è‚É£ When to Use Decorator Pattern**

Use it when:

* You want to **add functionality dynamically** (e.g., at runtime).
* You **can‚Äôt or shouldn‚Äôt modify** existing code (Open/Closed Principle).
* You want to **avoid subclass explosion** (more on that next üëá).

---

## üí£ What Is **Class Explosion**?

### **Definition**

> **Class Explosion** happens when you create **too many subclasses** to represent all possible combinations of features or behaviors.

This leads to:

* A **huge number of classes**.
* Difficulty in **maintaining** or **extending** code.
* **Duplication** of logic across subclasses.

---

### **Example Without Decorator Pattern**

Let‚Äôs say you‚Äôre designing a coffee system.

You start with:

* `SimpleCoffee`
* Then you want milk ‚Üí `CoffeeWithMilk`
* Then whipped cream ‚Üí `CoffeeWithWhip`
* Then milk and whipped cream ‚Üí `CoffeeWithMilkAndWhip`
* Then chocolate ‚Üí `CoffeeWithChocolate`
* Then milk + chocolate ‚Üí `CoffeeWithMilkAndChocolate`
* etc.

‚ò†Ô∏è You‚Äôll quickly end up with **dozens of subclasses** just to handle all combinations.

This is what we call **‚ÄúClass Explosion‚Äù**.

---

### **Why Decorator Solves This**

With the **Decorator Pattern**, you don‚Äôt need separate classes for every combination.

You can **dynamically compose** objects at runtime:

```java
Coffee coffee = new WhipDecorator(new MilkDecorator(new SimpleCoffee()));
```

This is far cleaner and more flexible.

---

## üß† Summary Table

| Concept                 | Explanation                                                          | Example                                        |
| ----------------------- | -------------------------------------------------------------------- | ---------------------------------------------- |
| **Decorator Pattern**   | Adds responsibilities to objects dynamically without altering class. | Wrapping coffee with milk or whip.             |
| **Class Explosion**     | Too many subclasses due to feature combinations.                     | CoffeeWithMilkAndWhipAndChocolate etc.         |
| **How Decorator helps** | Avoids subclassing by wrapping objects.                              | `new WhipDecorator(new MilkDecorator(coffee))` |

---

### ‚úÖ Key Takeaways

* The **Decorator Pattern** is about **composition over inheritance**.
* It **avoids class explosion** by **layering behaviors dynamically**.
* It **follows the Open/Closed Principle** ‚Äî open for extension, closed for modification.
* It‚Äôs heavily used in Java libraries ‚Äî for example:

  * `BufferedReader(new InputStreamReader(System.in))`
  * `Collections.synchronizedList(list)`

---

Would you like me to also show **UML diagram visualization + real-world code example (like logging, compression, or encryption decorators)** to see how this pattern is applied in backend systems (like a middleware chain)?


